'use client';

import { useEffect, useRef, useState } from 'react';

export default function AnimatedBackground() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [hoveredCell, setHoveredCell] = useState<{row: number, col: number} | null>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Game of Life configuration
    const CELL_SIZE = 12;
    let cols: number;
    let rows: number;
    let grid: boolean[][];
    let nextGrid: boolean[][];

    // Add some classic Conway's Game of Life patterns
    const addPattern = (startRow: number, startCol: number, pattern: number[][]) => {
      pattern.forEach((row, i) => {
        row.forEach((cell, j) => {
          const newRow = (startRow + i) % rows;
          const newCol = (startCol + j) % cols;
          if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
            grid[newRow][newCol] = cell === 1;
          }
        });
      });
    };

    // Classic patterns
    const patterns = {
      // Blinker (period 2)
      blinker: [
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0]
      ],
      // Toad (period 2)
      toad: [
        [0, 1, 1, 1],
        [1, 1, 1, 0]
      ],
      // Beacon (period 2)
      beacon: [
        [1, 1, 0, 0],
        [1, 1, 0, 0],
        [0, 0, 1, 1],
        [0, 0, 1, 1]
      ],
      // Glider (moves diagonally)
      glider: [
        [0, 1, 0],
        [0, 0, 1],
        [1, 1, 1]
      ],
      // Pentadecathlon (period 15)
      pentadecathlon: [
        [0, 0, 1, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 1, 0, 1, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 1, 0, 0]
      ],
      // Cloverleaf (oscillator)
      cloverleaf: [
        [0, 0, 1, 0, 0],
        [0, 1, 0, 1, 0],
        [1, 0, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 1, 0, 0]
      ],
    };

    // Set canvas size and initialize grid
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cols = Math.floor(canvas.width / CELL_SIZE);
      rows = Math.floor(canvas.height / CELL_SIZE);
      
      // Initialize grids
      grid = Array(rows).fill(null).map(() => Array(cols).fill(false));
      nextGrid = Array(rows).fill(null).map(() => Array(cols).fill(false));
      
      // Define text area to avoid (center area where main text appears)
      const centerRow = Math.floor(rows * 0.5);
      const centerCol = Math.floor(cols * 0.5);
      const textAreaWidth = Math.floor(cols * 0.8); // 80% of width (increased for better clarity)
      const textAreaHeight = Math.floor(rows * 0.5); // 50% of height (increased for better clarity)
      
      // Fill in more patterns around the edges and corners
      if (rows > 20 && cols > 20) {
        // Top area patterns - increased density
        for (let i = 0; i < 15; i++) {
          const row = Math.floor(Math.random() * (rows * 0.25));
          const col = Math.floor(Math.random() * cols);
          const patternType = Math.floor(Math.random() * 3);
          
          if (patternType === 0) addPattern(row, col, patterns.blinker);
          else if (patternType === 1) addPattern(row, col, patterns.toad);
          else addPattern(row, col, patterns.beacon);
        }
        
        // Bottom area patterns - increased density
        for (let i = 0; i < 15; i++) {
          const row = Math.floor(rows * 0.75) + Math.floor(Math.random() * (rows * 0.25));
          const col = Math.floor(Math.random() * cols);
          const patternType = Math.floor(Math.random() * 3);
          
          if (patternType === 0) addPattern(row, col, patterns.blinker);
          else if (patternType === 1) addPattern(row, col, patterns.toad);
          else addPattern(row, col, patterns.beacon);
        }
        
        // Left side patterns - increased density
        for (let i = 0; i < 12; i++) {
          const row = Math.floor(Math.random() * rows);
          const col = Math.floor(Math.random() * (cols * 0.25));
          // Skip if in text area
          if (Math.abs(row - centerRow) < textAreaHeight / 2) continue;
          
          const patternType = Math.floor(Math.random() * 3);
          if (patternType === 0) addPattern(row, col, patterns.blinker);
          else if (patternType === 1) addPattern(row, col, patterns.toad);
          else addPattern(row, col, patterns.beacon);
        }
        
        // Right side patterns - increased density
        for (let i = 0; i < 12; i++) {
          const row = Math.floor(Math.random() * rows);
          const col = Math.floor(cols * 0.75) + Math.floor(Math.random() * (cols * 0.25));
          // Skip if in text area
          if (Math.abs(row - centerRow) < textAreaHeight / 2) continue;
          
          const patternType = Math.floor(Math.random() * 3);
          if (patternType === 0) addPattern(row, col, patterns.blinker);
          else if (patternType === 1) addPattern(row, col, patterns.toad);
          else addPattern(row, col, patterns.beacon);
        }
        
        // Add more random cells for increased activity (avoiding text area)
        for (let i = 0; i < 200; i++) {
          const row = Math.floor(Math.random() * rows);
          const col = Math.floor(Math.random() * cols);
          
          // Skip if in text area
          const inTextArea = Math.abs(row - centerRow) < textAreaHeight / 2 && 
                            Math.abs(col - centerCol) < textAreaWidth / 2;
          
          if (!inTextArea && Math.random() < 0.4) {
            grid[row][col] = true;
          }
        }
      }
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Track scroll position
    const handleScroll = () => {
      setScrollY(window.scrollY);
    };
    window.addEventListener('scroll', handleScroll);

    // Handle canvas clicks to place random patterns
    const handleCanvasClick = (event: MouseEvent) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      const col = Math.floor(x / CELL_SIZE);
      const row = Math.floor(y / CELL_SIZE);
      
      if (row >= 0 && row < rows && col >= 0 && col < cols) {
        // Get all pattern names
        const patternNames = Object.keys(patterns) as (keyof typeof patterns)[];
        
        // Select a random pattern
        const randomPatternName = patternNames[Math.floor(Math.random() * patternNames.length)];
        const selectedPattern = patterns[randomPatternName];
        
        // Add the pattern at the click location
        addPattern(row, col, selectedPattern);
        
        // If shift is held, place a second random pattern nearby
        if (event.shiftKey) {
          const offsetRow = row + Math.floor(Math.random() * 10) - 5;
          const offsetCol = col + Math.floor(Math.random() * 10) - 5;
          const secondPatternName = patternNames[Math.floor(Math.random() * patternNames.length)];
          const secondPattern = patterns[secondPatternName];
          addPattern(offsetRow, offsetCol, secondPattern);
        }
      }
    };

    canvas.addEventListener('click', handleCanvasClick);

    // Handle mouse move for hover effect and mouse tracking
    const handleMouseMove = (event: MouseEvent) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      // Update mouse position for dynamic effects
      setMousePosition({ 
        x: (x / canvas.width) * 2 - 1,  // Normalize to -1 to 1
        y: (y / canvas.height) * 2 - 1 
      });
      
      const col = Math.floor(x / CELL_SIZE);
      const row = Math.floor(y / CELL_SIZE);
      
      if (row >= 0 && row < rows && col >= 0 && col < cols) {
        setHoveredCell({ row, col });
        
        // Add some cells around mouse for interactivity
        const influence = 2;
        for (let i = -influence; i <= influence; i++) {
          for (let j = -influence; j <= influence; j++) {
            const newRow = row + i;
            const newCol = col + j;
            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
              if (Math.random() < 0.3) { // 30% chance to activate nearby cells
                grid[newRow][newCol] = true;
              }
            }
          }
        }
      } else {
        setHoveredCell(null);
      }
    };

    const handleMouseLeave = () => {
      setHoveredCell(null);
    };

    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseleave', handleMouseLeave);

    // Count living neighbors
    const countNeighbors = (row: number, col: number): number => {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue; // Skip the cell itself
          
          const newRow = (row + i + rows) % rows; // Wrap around edges
          const newCol = (col + j + cols) % cols;
          
          if (grid[newRow][newCol]) {
            count++;
          }
        }
      }
      return count;
    };

    // Update grid according to Conway's rules
    const updateGrid = () => {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const neighbors = countNeighbors(row, col);
          const isAlive = grid[row][col];
          
          // Conway's Game of Life rules:
          // 1. Any live cell with 2-3 neighbors survives
          // 2. Any dead cell with exactly 3 neighbors becomes alive
          // 3. All other cells die or stay dead
          if (isAlive && (neighbors === 2 || neighbors === 3)) {
            nextGrid[row][col] = true;
          } else if (!isAlive && neighbors === 3) {
            nextGrid[row][col] = true;
          } else {
            nextGrid[row][col] = false;
          }
        }
      }
      
      // Swap grids
      [grid, nextGrid] = [nextGrid, grid];
    };

    // Draw the grid
    const drawGrid = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw hover indicator first (so it appears behind alive cells)
      if (hoveredCell && hoveredCell.row < rows && hoveredCell.col < cols) {
        const x = hoveredCell.col * CELL_SIZE;
        const y = hoveredCell.row * CELL_SIZE;
        
        ctx.save();
        ctx.fillStyle = '#60a5fa'; // Blue-400 for hover
        ctx.globalAlpha = 0.2;
        ctx.fillRect(x, y, CELL_SIZE - 1, CELL_SIZE - 1);
        ctx.strokeStyle = '#60a5fa';
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, CELL_SIZE - 1, CELL_SIZE - 1);
        ctx.restore();
      }
      
      // Draw alive cells
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          if (grid[row][col]) {
            const x = col * CELL_SIZE;
            const y = row * CELL_SIZE;
            
            // Check if this is the hovered cell for enhanced visibility
            const isHovered = hoveredCell && hoveredCell.row === row && hoveredCell.col === col;
            
            // Calculate gradient opacity based on distance from text center
            const centerRow = Math.floor(rows * 0.5);
            const centerCol = Math.floor(cols * 0.5);
            const textAreaWidth = Math.floor(cols * 0.8);
            const textAreaHeight = Math.floor(rows * 0.5);
            
            // Calculate distance from center of text area
            const distanceFromCenterX = Math.abs(col - centerCol) / (textAreaWidth / 2);
            const distanceFromCenterY = Math.abs(row - centerRow) / (textAreaHeight / 2);
            
            // Use the maximum distance (creates rectangular gradient)
            const maxDistance = Math.max(distanceFromCenterX, distanceFromCenterY);
            
            // Create gradient effect: full opacity outside text area, fade to 15% at center
            let opacityMultiplier = 1.0;
            if (maxDistance < 1.0) {
              // Inside text area - create smooth gradient
              opacityMultiplier = 0.15 + (maxDistance * 0.85); // 15% at center, 100% at edges
            }

            // Calculate distance from mouse for interactive effects
            const mouseInfluence = Math.sqrt(
              Math.pow((col / cols) - (mousePosition.x + 1) / 2, 2) +
              Math.pow((row / rows) - (mousePosition.y + 1) / 2, 2)
            );
            
            // Scroll-based color shifting
            const scrollInfluence = (scrollY / 1000) % 1; // Cycle through colors based on scroll
            
            ctx.save();
            
            // Dynamic color based on mouse proximity and scroll
            let baseColor = '#2563eb'; // Default blue
            if (mouseInfluence < 0.2) {
              baseColor = '#ec4899'; // Pink near mouse
            } else if (scrollInfluence > 0.5) {
              baseColor = '#8b5cf6'; // Purple when scrolled
            } else if (scrollInfluence > 0.25) {
              baseColor = '#06b6d4'; // Cyan
            }
            
            ctx.fillStyle = baseColor;
            ctx.shadowColor = baseColor;
            
            // Enhanced glow for mouse proximity and scroll effects
            const glowIntensity = isHovered ? 8 : (mouseInfluence < 0.15 ? 6 : 2);
            ctx.shadowBlur = glowIntensity + (scrollInfluence * 3);
            
            // Apply gradient opacity with scroll enhancement
            let alpha = isHovered ? 0.8 : 0.4;
            alpha = alpha * opacityMultiplier;
            
            // Boost alpha for mouse proximity
            if (mouseInfluence < 0.15) {
              alpha = Math.min(alpha * 1.5, 0.9);
            }
            
            ctx.globalAlpha = alpha;
            ctx.fillRect(x, y, CELL_SIZE - 1, CELL_SIZE - 1);
            ctx.restore();
          }
        }
      }
    };

    // Animation loop
    let lastUpdate = 0;
    const UPDATE_INTERVAL = 180; // Slightly slower tick rate for better observation of patterns
    
    const animate = (currentTime: number) => {
      if (currentTime - lastUpdate >= UPDATE_INTERVAL) {
        updateGrid();
        lastUpdate = currentTime;
      }
      
      drawGrid();
      requestAnimationFrame(animate);
    };

    animate(0);

    return () => {
      window.removeEventListener('resize', resizeCanvas);
      window.removeEventListener('scroll', handleScroll);
      canvas.removeEventListener('click', handleCanvasClick);
      canvas.removeEventListener('mousemove', handleMouseMove);
      canvas.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className="absolute inset-0 w-full h-full cursor-pointer"
      style={{ 
        zIndex: 1,
        background: 'transparent'
      }}
    />
  );
}
